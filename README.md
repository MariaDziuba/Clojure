# Clojure
itmo, paradigms of programming, hw9, hw10, hw11, hw12
## Домашнее задание 12. Комбинаторные парсеры

Реализуйте функцию (parseObjectSuffix "expression"), разбирающую выражения, записанные в суффиксной форме, и функцию toStringSuffix, возвращающую строковое представление выражения в этой форме. 

Например,
`(toStringSuffix (parseObjectSuffix "( ( 2 x * ) 3 - )"))`
должно возвращать `((2 x *) 3 -)`.

Функции разбора должны базироваться на библиотеке комбинаторов, разработанной на лекции.

**Модификации:**

* Базовая
  * Код должен находиться в файле expression.clj.
  * Запускать c аргументом easy или hard
* Variables. Дополнительно реализовать поддержку:
  * Переменных, состоящих из произвольного количества букв XYZ в любом регистре
  * Настоящее имя переменной определяется первой буквой ее имени
  
## Домашнее задание 11. Объектные выражения на Clojure

Разработайте конструкторы Constant, Variable, Add, Subtract, Multiply и Divide для представления выражений с одной переменной.

Пример описания выражения 2x-3:
`(def expr
  (Subtract
    (Multiply
      (Constant 2)
      (Variable "x"))
    (Const 3)))`
                    
Функция (evaluate expression vars) должна производить вычисление выражения expression для значений переменных, заданных отображением vars. 

Например, `(evaluate expr {"x" 2})` должно быть равно 1.

Функция `(toString expression)` должна выдавать запись выражения в стандартной для Clojure форме.

Функция `(parseObject "expression")` должна разбирать выражения, записанные в стандартной для Clojure форме. 
Например,
`(parseObject "(- (* 2 x) 3)")`
должно быть эквивалентно expr.

Функция `(diff expression "variable")` должена возвращать выражение, представляющее производную исходного выражения по заданой пермененной. 

Например, `(diff expression "x")` должен возвращать выражение, эквивалентное `(Constant 2)`, при этом выражения `(Subtract (Const 2) (Const 0))` и
`(Subtract
  (Add
    (Multiply (Const 0) (Variable "x"))
    (Multiply (Const 2) (Const 1)))
  (Const 0))` так же будут считаться правильным ответом.

При выполнении задания можно использовать любой способ преставления объектов.

**Модификации:**

* Базовая
  * Код должен находиться в файле expression.clj.
  * Запускать c аргументом easy или hard
* ExpLn. Дополнительно реализовать поддержку:
  * унарных операций:
  * Exp (exp) – экспонента, (exp 8) примерно равно 2981;
  * Ln (Ln) – натуральный логарифм абсолютной величины, (lg 2981) примерно равно 8.

## Домашнее задание 10. Функциональные выражения на Clojure

Разработайте функции constant, variable, add, subtract, multiply и divide для представления арифметических выражений.

Пример описания выражения 2x-3:

`(def expr
  (subtract
    (multiply
      (constant 2)
      (variable "x"))
    (constant 3)))`
                    
Выражение должно быть функцией, возвращающей значение выражение при подстановке элементов, заданных отображением. 
Например, `(expr {"x" 2})` должно быть равно 1.

Разработайте разборщик выражений, читающий выражения в стандартной для Clojure форме. 

Например,
`(parseFunction "(- (* 2 x) 3)")`
должно быть эквивалентно expr.

При выполнение задания следует обратить внимание на:
* Выделение общего кода для операций.

**Модификации:**

* Базовая
  * Код должен находиться в файле expression.clj.
  * Запускать c аргументом easy или hard
* ExpLn. Дополнительно реализовать поддержку:
  * унарных операций:
  * exp – экспонента, (exp 8) примерно равно 2981;
  * ln – натуральный логарифм абсолютной величины, (ln -2981) примерно равно 8.

## Домашнее задание 9. Линейная алгебра на Clojure
Разработайте функции для работы с объектами линейной алгебры, которые представляются следующим образом:
* скаляры – числа
* векторы – векторы чисел;
* матрицы – векторы векторов чисел.
Функции над векторами:
* v+/v-/v* – покоординатное сложение/вычитание/умножение;
* scalar/vect – скалярное/векторное произведение;
* v*s – умножение на скаляр.
Функции над матрицами:
* m+/m-/m* – поэлементное сложение/вычитание/умножение;
* m*s – умножение на скаляр;
* m*v – умножение на вектор;
* m*m – матричное умножение;
* transpose – траспонирование;
При выполнение задания следует обратить внимание на:
* Применение функций высшего порядка.
* Выделение общего кода для операций.

**Модификации:**

* Базовая
  * Код должен находиться в файле linear.clj.

* Cuboid
  * Назовем кубоидом трехмерную прямоугольную таблицу чисел.
  * Добавьте операции поэлементного сложения (c+), вычитания (c-), умножения (c*) и деления (cd) кубоидов. Например, `(с+ [[[1] [2]] [[3] [4]]] [[[5] [6]] [[7] [8]]])` должно быть равно `[[[6] [8]] [[10] [12]]]`.


Для запуска тестов можно использовать скрипты TestClojure.cmd и TestClojure.sh

Репозиторий должен быть скачан целиком.

Скрипты должны находиться в каталоге clojure (их нельзя перемещать, но можно вызывать из других каталогов).

Полное имя класса теста указывается в качестве аргумента командной строки, например, cljtest.linear.LinearBinaryTest.

Тестируемое решение должно находиться в текущем каталоге.
